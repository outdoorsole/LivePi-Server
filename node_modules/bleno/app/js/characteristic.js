/*
* TODO:
* parse wpa_supplicant.conf, add ability to remove incorrect network
*/
var util = require('util');
var bleno = require('../..');
var secrets = require('./secrets');

var BlenoCharacteristic = bleno.Characteristic;

var wifiIsUp = true;
var ngrokRunning = false;
var publicStreamIsActive = false;
var privateStreamIsActive = false;
var waitingForUv4lStopBeforeStartingPublicStream = false;

var EchoCharacteristic = function() {
  EchoCharacteristic.super_.call(this, {
    uuid: 'ec0e',
    properties: ['read', 'write', 'notify'],
    value: null
  });

  this._value = new Buffer(0);
  this._updateValueCallback = null;
  
  checkInternetConnection();
};

util.inherits(EchoCharacteristic, BlenoCharacteristic);

EchoCharacteristic.prototype.onReadRequest = function(offset, callback) {
  console.log('EchoCharacteristic - onReadRequest: value = ' + this._value.toString('utf8'));

  callback(this.RESULT_SUCCESS, this._value);
};

// received data from connected BLE device
EchoCharacteristic.prototype.onWriteRequest = function(data, offset, withoutResponse, callback) {
  var dataAsString = data.toString('utf8');
  console.log('received data from host: ' + dataAsString);
  var parsedData = dataAsString.split(",");
  
  this._value = new Buffer("command_not_recognized", "utf-8");
  
  if (parsedData.length == 3 && parsedData[0] == "wifi"){ // receiving wifi SSID and password
	var ssid = parsedData[1];
    var password = parsedData[2];
	  
	var newNetwork = [
		"\nnetwork={\n",
		"	ssid=\""+ssid+"\"\n",
		"	psk=\""+password+"\"\n",
		"	key_mgmt=WPA-PSK\n",
		"}\n"
	];

	  var fs = require('fs')
	  for (i=0; i<newNetwork.length; i++) {
		fs.appendFile('/etc/wpa_supplicant/wpa_supplicant.conf', newNetwork[i], function(err) {
			if (err) return console.log(err);
		});
	  }
	  console.log('Appended network to wpa_supplicant.conf');
      
	  enableWifi();
	  
	  this._value = new Buffer("added_network", "utf-8");
  }
  else if (parsedData.length == 1 && parsedData[0] == "status") {
	  if(wifiIsUp){
		this._value = new Buffer("wifi_connected", "utf-8");
	  }
	  else {
		this._value = new Buffer("wifi_down", "utf-8");
	  }
  }
  else if (parsedData.length == 1 && parsedData[0] == "sps"){ // start public stream
	  startPublicStream();
	  this._value = new Buffer("starting_public", "utf-8");
  }
  else if (parsedData.length == 1 && parsedData[0] == "eps"){ // end public stream
	  stopPublicStream();
	  this._value = new Buffer("stopping_public", "utf-8");
  }
  
  if (this._updateValueCallback) {
	this._updateValueCallback(this._value);
  }
      
  callback(this.RESULT_SUCCESS);
};

EchoCharacteristic.prototype.onSubscribe = function(maxValueSize, updateValueCallback) {
  console.log('EchoCharacteristic - onSubscribe');

  this._updateValueCallback = updateValueCallback;
};

EchoCharacteristic.prototype.onUnsubscribe = function() {
  console.log('EchoCharacteristic - onUnsubscribe');

  this._updateValueCallback = null;
};
module.exports = EchoCharacteristic;

function checkInternetConnection() {
	require('dns').resolve('www.google.com', function connected(err) {
		if (err) {
			console.log('no internet connection');
			disableWifi();
		}
		else {
			console.log('connected to internet');
			startNgrok();
		}
	});
}

function startNgrok() {
	var ngrok = require('ngrok');
	
	console.log('starting ngrok');
	
	ngrok.connect({
		proto: 'http',
		addr: '80',
		subdomain: secrets.ngrokURL,
		authtoken: secrets.ngrokToken
	}, function (err, url) {});
	
	setTimeout(startPrivateStream, 2000);
}

function startPublicStream() {
	startFfmpegForPublicStream();
	setTimeout(startPicamForPublicStream, 2000);
}

/////////////////////////////////////////////////////////////////////////////////////
//Commands
/////////////////////////////////////////////////////////////////////////////////////


function startPrivateStream() {
	console.log('starting private stream');
	
	// default landscape: 320 x 240
	// iOS portrait: 215 x 326
	
	'use strict';
	const
	spawn = require( 'child_process' ).spawn,
	ls = spawn('uv4l', ['--auto-video_nr', '--sched-rr', '--driver', 'raspicam', '--encoding', 'h264', '--framerate', '10', '--drop-bad-frames', 'yes', '--width', '215', '--height', '326', '--server-option', '--port=80' ]);

	ls.stdout.on( 'data', data => {
		console.log( `stdout: ${data}` );
	});

	ls.stderr.on( 'data', data => {
		console.log( `stderr: ${data}` );
	});

	ls.on( 'close', code => {
		console.log( `child process exited with code ${code}` );
		console.log('stream is active');
		privateStreamIsActive = true;
	});
}

function disableWifi() {
	console.log('disabling wifi');
	
	'use strict';
	const
		spawn = require( 'child_process' ).spawn,
		ls = spawn('sudo', ['ifdown', 'wlan0']);

	ls.stdout.on( 'data', data => {
		console.log( `stdout: ${data}` );
	});

	ls.stderr.on( 'data', data => {
		console.log( `stderr: ${data}` );
	});

	ls.on( 'close', code => {
		console.log( `child process exited with code ${code}` );
		console.log('wifi is down');
		wifiIsUp = false;
	});
}

function enableWifi(){
	console.log('enabling wifi');
	
	'use strict';
	const
	spawn = require( 'child_process' ).spawn,
	ls = spawn('sudo', ['ifup', 'wlan0']);

	ls.stdout.on( 'data', data => {
		console.log( `stdout: ${data}` );
	});

	ls.stderr.on( 'data', data => {
		console.log( `stderr: ${data}` );
	});

	ls.on( 'close', code => {
		console.log( `child process exited with code ${code}` );
		console.log('wifi is up');
		wifiIsUp = true;
		
		setTimeout(startNgrok, 1000);
	});
}

function startFfmpegForPublicStream() {
	console.log('starting ffmpeg for public stream');
	
	'use strict';
	const
	spawn = require( 'child_process' ).spawn,
	ls = spawn('/home/pi/Desktop/ffmpeg/bin/ffmpeg', ['-i', 'tcp://127.0.0.1:8081?listen', '-c:v', 'copy', '-c:a', 'aac', '-ar', '44100', '-ab', '128k', '-strict', '-2', '-f', 'flv', 'rtmp://a.rtmp.youtube.com/live2/' + secrets.youtubeStreamKey]);

	ls.stdout.on( 'data', data => {
		console.log( `stdout: ${data}` );
	});

	ls.stderr.on( 'data', data => {
		console.log( `stderr: ${data}` );
	});

	ls.on( 'close', code => {
		console.log( `child process exited with code ${code}` );
		console.log('ffmpeg listening for stream from picam');
	});
}

function stopFfmpeg(){
	console.log('stopping ffmpeg');
	
	'use strict';
	const
	spawn = require( 'child_process' ).spawn,
	ls = spawn('sudo', ['pkill', '/home/pi/Desktop/ffmpeg/bin/ffmpeg']);

	ls.stdout.on( 'data', data => {
		console.log( `stdout: ${data}` );
	});

	ls.stderr.on( 'data', data => {
		console.log( `stderr: ${data}` );
	});

	ls.on( 'close', code => {
		console.log( `child process exited with code ${code}` );
		console.log('ffmpeg stopped');
		publicStreamIsActive = false;
	});
}

function startPicamForPublicStream() {
	console.log('starting picam for public stream');

	'use strict';
	const
	spawn = require( 'child_process' ).spawn,
	ls = spawn('/home/pi/Desktop/picam/./picam', ['--samplerate', '44100', '--audiobitrate', '128000', '--alsadev', 'hw:1,0', '--volume', '5', '--tcpout', 'tcp://127.0.0.1:8081']);

	ls.stdout.on( 'data', data => {
		console.log( `stdout: ${data}` );
	});

	ls.stderr.on( 'data', data => {
		console.log( `stderr: ${data}` );
	});

	ls.on( 'close', code => {
		console.log( `child process exited with code ${code}` );
		console.log('picam is running');
		publicStreamIsActive = true;
	});
}

function stopPublicStream(){
	console.log('stopping public stream');
	
	'use strict';
	const
	spawn = require( 'child_process' ).spawn,
	ls = spawn('sudo', ['pkill', 'picam']);

	ls.stdout.on( 'data', data => {
		console.log( `stdout: ${data}` );
	});

	ls.stderr.on( 'data', data => {
		console.log( `stderr: ${data}` );
	});

	ls.on( 'close', code => {
		console.log( `child process exited with code ${code}` );
		console.log('picam stopped');
		publicStreamIsActive = false;
		setTimeout(stopFfmpeg, 1000);
	});
}
